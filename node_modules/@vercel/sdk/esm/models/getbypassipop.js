/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
export const GetBypassIpResponseBodyAction = {
    Block: "block",
    Bypass: "bypass",
};
export const ResponseBodyAction = {
    Block: "block",
    Bypass: "bypass",
};
/** @internal */
export const GetBypassIpRequest$inboundSchema = z.object({
    projectId: z.string(),
    limit: z.number().optional(),
    sourceIp: z.string().optional(),
    domain: z.string().optional(),
    projectScope: z.boolean().optional(),
    offset: z.string().optional(),
    teamId: z.string().optional(),
    slug: z.string().optional(),
});
/** @internal */
export const GetBypassIpRequest$outboundSchema = z.object({
    projectId: z.string(),
    limit: z.number().optional(),
    sourceIp: z.string().optional(),
    domain: z.string().optional(),
    projectScope: z.boolean().optional(),
    offset: z.string().optional(),
    teamId: z.string().optional(),
    slug: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpRequest$;
(function (GetBypassIpRequest$) {
    /** @deprecated use `GetBypassIpRequest$inboundSchema` instead. */
    GetBypassIpRequest$.inboundSchema = GetBypassIpRequest$inboundSchema;
    /** @deprecated use `GetBypassIpRequest$outboundSchema` instead. */
    GetBypassIpRequest$.outboundSchema = GetBypassIpRequest$outboundSchema;
})(GetBypassIpRequest$ || (GetBypassIpRequest$ = {}));
export function getBypassIpRequestToJSON(getBypassIpRequest) {
    return JSON.stringify(GetBypassIpRequest$outboundSchema.parse(getBypassIpRequest));
}
export function getBypassIpRequestFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpRequest$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpRequest' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBodyAction$inboundSchema = z.nativeEnum(GetBypassIpResponseBodyAction);
/** @internal */
export const GetBypassIpResponseBodyAction$outboundSchema = GetBypassIpResponseBodyAction$inboundSchema;
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBodyAction$;
(function (GetBypassIpResponseBodyAction$) {
    /** @deprecated use `GetBypassIpResponseBodyAction$inboundSchema` instead. */
    GetBypassIpResponseBodyAction$.inboundSchema = GetBypassIpResponseBodyAction$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBodyAction$outboundSchema` instead. */
    GetBypassIpResponseBodyAction$.outboundSchema = GetBypassIpResponseBodyAction$outboundSchema;
})(GetBypassIpResponseBodyAction$ || (GetBypassIpResponseBodyAction$ = {}));
/** @internal */
export const GetBypassIpResponseBodyResult$inboundSchema = z.object({
    OwnerId: z.string().optional(),
    Id: z.string().optional(),
    Domain: z.string().optional(),
    Ip: z.string().optional(),
    Action: GetBypassIpResponseBodyAction$inboundSchema.optional(),
    ProjectId: z.string().optional(),
    IsProjectRule: z.boolean().optional(),
    Note: z.string().optional(),
    CreatedAt: z.string().optional(),
    ActorId: z.string().optional(),
    UpdatedAt: z.string().optional(),
    UpdatedAtHour: z.string().optional(),
    DeletedAt: z.string().optional(),
    ExpiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
        "Domain": "domain",
        "Ip": "ip",
        "Action": "action",
        "ProjectId": "projectId",
        "IsProjectRule": "isProjectRule",
        "Note": "note",
        "CreatedAt": "createdAt",
        "ActorId": "actorId",
        "UpdatedAt": "updatedAt",
        "UpdatedAtHour": "updatedAtHour",
        "DeletedAt": "deletedAt",
        "ExpiresAt": "expiresAt",
    });
});
/** @internal */
export const GetBypassIpResponseBodyResult$outboundSchema = z.object({
    ownerId: z.string().optional(),
    id: z.string().optional(),
    domain: z.string().optional(),
    ip: z.string().optional(),
    action: GetBypassIpResponseBodyAction$outboundSchema.optional(),
    projectId: z.string().optional(),
    isProjectRule: z.boolean().optional(),
    note: z.string().optional(),
    createdAt: z.string().optional(),
    actorId: z.string().optional(),
    updatedAt: z.string().optional(),
    updatedAtHour: z.string().optional(),
    deletedAt: z.string().optional(),
    expiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
        domain: "Domain",
        ip: "Ip",
        action: "Action",
        projectId: "ProjectId",
        isProjectRule: "IsProjectRule",
        note: "Note",
        createdAt: "CreatedAt",
        actorId: "ActorId",
        updatedAt: "UpdatedAt",
        updatedAtHour: "UpdatedAtHour",
        deletedAt: "DeletedAt",
        expiresAt: "ExpiresAt",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBodyResult$;
(function (GetBypassIpResponseBodyResult$) {
    /** @deprecated use `GetBypassIpResponseBodyResult$inboundSchema` instead. */
    GetBypassIpResponseBodyResult$.inboundSchema = GetBypassIpResponseBodyResult$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBodyResult$outboundSchema` instead. */
    GetBypassIpResponseBodyResult$.outboundSchema = GetBypassIpResponseBodyResult$outboundSchema;
})(GetBypassIpResponseBodyResult$ || (GetBypassIpResponseBodyResult$ = {}));
export function getBypassIpResponseBodyResultToJSON(getBypassIpResponseBodyResult) {
    return JSON.stringify(GetBypassIpResponseBodyResult$outboundSchema.parse(getBypassIpResponseBodyResult));
}
export function getBypassIpResponseBodyResultFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBodyResult$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBodyResult' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBodyPagination$inboundSchema = z.object({
    OwnerId: z.string(),
    Id: z.string(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
    });
});
/** @internal */
export const GetBypassIpResponseBodyPagination$outboundSchema = z.object({
    ownerId: z.string(),
    id: z.string(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBodyPagination$;
(function (GetBypassIpResponseBodyPagination$) {
    /** @deprecated use `GetBypassIpResponseBodyPagination$inboundSchema` instead. */
    GetBypassIpResponseBodyPagination$.inboundSchema = GetBypassIpResponseBodyPagination$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBodyPagination$outboundSchema` instead. */
    GetBypassIpResponseBodyPagination$.outboundSchema = GetBypassIpResponseBodyPagination$outboundSchema;
})(GetBypassIpResponseBodyPagination$ || (GetBypassIpResponseBodyPagination$ = {}));
export function getBypassIpResponseBodyPaginationToJSON(getBypassIpResponseBodyPagination) {
    return JSON.stringify(GetBypassIpResponseBodyPagination$outboundSchema.parse(getBypassIpResponseBodyPagination));
}
export function getBypassIpResponseBodyPaginationFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBodyPagination$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBodyPagination' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBody2$inboundSchema = z.object({
    result: z.array(z.lazy(() => GetBypassIpResponseBodyResult$inboundSchema))
        .optional(),
    pagination: z.lazy(() => GetBypassIpResponseBodyPagination$inboundSchema)
        .optional(),
});
/** @internal */
export const GetBypassIpResponseBody2$outboundSchema = z.object({
    result: z.array(z.lazy(() => GetBypassIpResponseBodyResult$outboundSchema))
        .optional(),
    pagination: z.lazy(() => GetBypassIpResponseBodyPagination$outboundSchema)
        .optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBody2$;
(function (GetBypassIpResponseBody2$) {
    /** @deprecated use `GetBypassIpResponseBody2$inboundSchema` instead. */
    GetBypassIpResponseBody2$.inboundSchema = GetBypassIpResponseBody2$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBody2$outboundSchema` instead. */
    GetBypassIpResponseBody2$.outboundSchema = GetBypassIpResponseBody2$outboundSchema;
})(GetBypassIpResponseBody2$ || (GetBypassIpResponseBody2$ = {}));
export function getBypassIpResponseBody2ToJSON(getBypassIpResponseBody2) {
    return JSON.stringify(GetBypassIpResponseBody2$outboundSchema.parse(getBypassIpResponseBody2));
}
export function getBypassIpResponseBody2FromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBody2$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBody2' from JSON`);
}
/** @internal */
export const ResponseBodyAction$inboundSchema = z.nativeEnum(ResponseBodyAction);
/** @internal */
export const ResponseBodyAction$outboundSchema = ResponseBodyAction$inboundSchema;
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ResponseBodyAction$;
(function (ResponseBodyAction$) {
    /** @deprecated use `ResponseBodyAction$inboundSchema` instead. */
    ResponseBodyAction$.inboundSchema = ResponseBodyAction$inboundSchema;
    /** @deprecated use `ResponseBodyAction$outboundSchema` instead. */
    ResponseBodyAction$.outboundSchema = ResponseBodyAction$outboundSchema;
})(ResponseBodyAction$ || (ResponseBodyAction$ = {}));
/** @internal */
export const ResponseBodyResult$inboundSchema = z.object({
    OwnerId: z.string().optional(),
    Id: z.string().optional(),
    Domain: z.string().optional(),
    Ip: z.string().optional(),
    Action: ResponseBodyAction$inboundSchema.optional(),
    ProjectId: z.string().optional(),
    IsProjectRule: z.boolean().optional(),
    Note: z.string().optional(),
    CreatedAt: z.string().optional(),
    ActorId: z.string().optional(),
    UpdatedAt: z.string().optional(),
    UpdatedAtHour: z.string().optional(),
    DeletedAt: z.string().optional(),
    ExpiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
        "Domain": "domain",
        "Ip": "ip",
        "Action": "action",
        "ProjectId": "projectId",
        "IsProjectRule": "isProjectRule",
        "Note": "note",
        "CreatedAt": "createdAt",
        "ActorId": "actorId",
        "UpdatedAt": "updatedAt",
        "UpdatedAtHour": "updatedAtHour",
        "DeletedAt": "deletedAt",
        "ExpiresAt": "expiresAt",
    });
});
/** @internal */
export const ResponseBodyResult$outboundSchema = z.object({
    ownerId: z.string().optional(),
    id: z.string().optional(),
    domain: z.string().optional(),
    ip: z.string().optional(),
    action: ResponseBodyAction$outboundSchema.optional(),
    projectId: z.string().optional(),
    isProjectRule: z.boolean().optional(),
    note: z.string().optional(),
    createdAt: z.string().optional(),
    actorId: z.string().optional(),
    updatedAt: z.string().optional(),
    updatedAtHour: z.string().optional(),
    deletedAt: z.string().optional(),
    expiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
        domain: "Domain",
        ip: "Ip",
        action: "Action",
        projectId: "ProjectId",
        isProjectRule: "IsProjectRule",
        note: "Note",
        createdAt: "CreatedAt",
        actorId: "ActorId",
        updatedAt: "UpdatedAt",
        updatedAtHour: "UpdatedAtHour",
        deletedAt: "DeletedAt",
        expiresAt: "ExpiresAt",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ResponseBodyResult$;
(function (ResponseBodyResult$) {
    /** @deprecated use `ResponseBodyResult$inboundSchema` instead. */
    ResponseBodyResult$.inboundSchema = ResponseBodyResult$inboundSchema;
    /** @deprecated use `ResponseBodyResult$outboundSchema` instead. */
    ResponseBodyResult$.outboundSchema = ResponseBodyResult$outboundSchema;
})(ResponseBodyResult$ || (ResponseBodyResult$ = {}));
export function responseBodyResultToJSON(responseBodyResult) {
    return JSON.stringify(ResponseBodyResult$outboundSchema.parse(responseBodyResult));
}
export function responseBodyResultFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ResponseBodyResult$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ResponseBodyResult' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBody1$inboundSchema = z.object({
    result: z.array(z.lazy(() => ResponseBodyResult$inboundSchema)),
    pagination: z.nullable(z.any()).optional(),
});
/** @internal */
export const GetBypassIpResponseBody1$outboundSchema = z.object({
    result: z.array(z.lazy(() => ResponseBodyResult$outboundSchema)),
    pagination: z.nullable(z.any()).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBody1$;
(function (GetBypassIpResponseBody1$) {
    /** @deprecated use `GetBypassIpResponseBody1$inboundSchema` instead. */
    GetBypassIpResponseBody1$.inboundSchema = GetBypassIpResponseBody1$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBody1$outboundSchema` instead. */
    GetBypassIpResponseBody1$.outboundSchema = GetBypassIpResponseBody1$outboundSchema;
})(GetBypassIpResponseBody1$ || (GetBypassIpResponseBody1$ = {}));
export function getBypassIpResponseBody1ToJSON(getBypassIpResponseBody1) {
    return JSON.stringify(GetBypassIpResponseBody1$outboundSchema.parse(getBypassIpResponseBody1));
}
export function getBypassIpResponseBody1FromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBody1$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBody1' from JSON`);
}
/** @internal */
export const GetBypassIpResponseBody$inboundSchema = z.union([
    z.lazy(() => GetBypassIpResponseBody1$inboundSchema),
    z.lazy(() => GetBypassIpResponseBody2$inboundSchema),
]);
/** @internal */
export const GetBypassIpResponseBody$outboundSchema = z.union([
    z.lazy(() => GetBypassIpResponseBody1$outboundSchema),
    z.lazy(() => GetBypassIpResponseBody2$outboundSchema),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GetBypassIpResponseBody$;
(function (GetBypassIpResponseBody$) {
    /** @deprecated use `GetBypassIpResponseBody$inboundSchema` instead. */
    GetBypassIpResponseBody$.inboundSchema = GetBypassIpResponseBody$inboundSchema;
    /** @deprecated use `GetBypassIpResponseBody$outboundSchema` instead. */
    GetBypassIpResponseBody$.outboundSchema = GetBypassIpResponseBody$outboundSchema;
})(GetBypassIpResponseBody$ || (GetBypassIpResponseBody$ = {}));
export function getBypassIpResponseBodyToJSON(getBypassIpResponseBody) {
    return JSON.stringify(GetBypassIpResponseBody$outboundSchema.parse(getBypassIpResponseBody));
}
export function getBypassIpResponseBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GetBypassIpResponseBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GetBypassIpResponseBody' from JSON`);
}
//# sourceMappingURL=getbypassipop.js.map